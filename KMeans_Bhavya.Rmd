---
title: "KMeans_Bhavya"
output: html_document
date: "2024-11-18"
---


```{r}
library(tidyverse)
library(readxl)
library(ggplot2)
library(readr)
library(caret)
library(dplyr)
library(fastDummies)
library(ROSE)
```

```{r}
# Load the data
Churn_Modelling <- read_excel("Churn_Modelling.xlsx")

# View the fields and data type
colnames(Churn_Modelling)
glimpse(Churn_Modelling)
```


```{r}
# Preprocess the variables
ChurnModelling1 = Churn_Modelling %>%
  mutate(across(c(Gender, HasCrCard, IsActiveMember, Exited), as.factor))

# Create dummy variables
ChurnModelling1 = dummy_cols(ChurnModelling1, select_columns = c("Geography", "Gender"), remove_first_dummy = TRUE, remove_selected_columns = TRUE)

# Remove unneeded columns
ChurnModelling1 = ChurnModelling1 %>% 
  select(-CustomerId, -Surname, -RowNumber)

glimpse(ChurnModelling1)

# Check for missing values
missing_values <- sapply(Churn_Modelling, function(x) sum(is.na(x)))
print(missing_values) # no missing values
```


```{r}
# Balance the data
data_balanced <- ovun.sample(Exited ~ ., data = ChurnModelling1, method = "both", p = 0.5)$data
str(data_balanced)
table(data_balanced$Exited)

# Convert factor columns to numeric
data_balanced_numeric <- data_balanced %>%
  mutate(across(where(is.factor), as.numeric))

# Normalize the data
data_normalized <- data_balanced_numeric %>%
  select(-Exited) %>%
  scale()
```


```{r}
# Determine the optimal number of clusters using the Elbow method
set.seed(123)
wss <- (nrow(data_normalized) - 1) * sum(apply(data_normalized, 2, var))
for (i in 2:15) wss[i] <- sum(kmeans(data_normalized, centers = i)$tot.withinss)

# Plot the Elbow method
plot(1:15, wss, type = "b", xlab = "Number of Clusters", ylab = "Within groups sum of squares")

# Apply k-means clustering with the chosen number of clusters (e.g., 3)
set.seed(123)
kmeans_result <- kmeans(data_normalized, centers = 3, nstart = 25)

# Add the cluster assignments to the original data
data_balanced$Cluster <- kmeans_result$cluster
```


```{r}
# CLUSTER ANALYSIS:

# Analyze the clusters using aggregate statistics
table(data_balanced$Cluster)
aggregate(data_balanced_numeric, by = list(data_balanced$Cluster), FUN = mean)

# Analyze the relationship between clusters and the target variable 'Exited'
table(data_balanced$Cluster, data_balanced$Exited)

# Visualize the relationship
ggplot(data_balanced, aes(x = as.factor(Cluster), fill = as.factor(Exited))) +
  geom_bar(position = "fill") +
  labs(title = "Proportion of Exited in Each Cluster", x = "Cluster", y = "Proportion", fill = "Exited") +
  theme_minimal()
```


```{r}
#plot.new()
#dev.off()
# Calculate the correlation matrix
library(corrplot)
cor_matrix <- cor(data_balanced_numeric)

# Plot the correlation matrix
corrplot(cor_matrix, method = "circle", type = "upper", tl.col = "black", tl.srt = 45)
```


```{r}
# Perform PCA on the normalized data
pca_result <- prcomp(data_normalized, center = TRUE, scale. = TRUE)

# Create a data frame with the principal components and cluster assignments
pca_data <- data.frame(pca_result$x[, 1:2], Cluster = as.factor(data_balanced$Cluster))

# Plot the clusters using ggplot2
ggplot(pca_data, aes(x = PC1, y = PC2, color = Cluster)) +
  geom_point(alpha = 0.5) +
  labs(title = "K-means Clustering with PCA", x = "Principal Component 1", y = "Principal Component 2") +
  theme_minimal() +
  geom_point(data = as.data.frame(predict(pca_result, kmeans_result$centers)), 
             aes(x = PC1, y = PC2), color = "black", size = 5, shape = 4, stroke = 2) +
  theme(legend.position = "bottom")


# Visualize the size of each cluster
ggplot(data_balanced, aes(x = as.factor(Cluster))) +
  geom_bar(fill = "blue", alpha = 0.7) +
  labs(title = "Cluster Sizes", x = "Cluster", y = "Count") +
  theme_minimal()
```


```{r}
# Install and load the fmsb package
library(fmsb)

# Prepare data for radar chart
cluster_profiles <- aggregate(data_balanced_numeric, by = list(data_balanced$Cluster), FUN = mean)
cluster_profiles <- cluster_profiles[, -1]  # Remove the cluster column

# Normalize the data for radar chart
cluster_profiles <- as.data.frame(scale(cluster_profiles))

# Add max and min values for radar chart
max_min <- data.frame(matrix(ncol = ncol(cluster_profiles), nrow = 2))
colnames(max_min) <- colnames(cluster_profiles)
max_min[1, ] <- apply(cluster_profiles, 2, max)
max_min[2, ] <- apply(cluster_profiles, 2, min)
cluster_profiles <- rbind(max_min, cluster_profiles)

# Plot radar chart for each cluster
par(mfrow = c(2, 3))  # Adjust the layout as needed
for (i in 3:nrow(cluster_profiles)) {
  radarchart(cluster_profiles[c(1, 2, i), ], axistype = 1,
             pcol = c("red", "blue", "green"), pfcol = c("red", "blue", "green"),
             plwd = 2, plty = 1, title = paste("Cluster", i - 2))
}
```



























